## Introduction to Observability
- [Overview](#overview)
- [Pillars of Observability](#pillars-of-observability)
- [SLI/SLO/SLA](#sli-slo-sla)

### Overview 

* `Observablity` is the ability to understand and measure the state of a system based on data generated by that system
  - It allows you to generate actionable outputs from scenerios in these environment
  - It gives us better insights of the system
  - Speed up troubleshooting
  - Detect hard to catch problems
  - Monitor performance of an application

* We want to better understand the internals of our system
  - With the rise of microservice applications, we find a greater need to track and understand what's happening within our system

* We want to know:
  - Why error rates are rising
  - Why there is high latency
  - Why services are timing out

### Pillars of Observability

* We can accomplish observability with 3 pillars:

  - `Logging`: 
    * records of events that have occurred and encapsulate info about that specific even
    * consists of timestamp of when log occurred and message containing information of said even
    * verbosity of logs can make it difficult to trace issues
  - `Metrics`:
    * provides us information about the state of a system using numerical data (e.g. `cpu load`, `number of open files`, `http response time`, `error rates`)
    * data thats collected can be aggregated
    * contains 4 pieces of information:

      ```
      node_filesystem_avail_bytes{fstype="vfat",mountpoint="/home"} 5000    4:30AM 12/1/22
                   |                            |                    |            |
             <metric name>                 <dimensions>            <value>   <timestamp>
      metric_name: name of the metric
      value: most recent of current value of the metric
      dimensions: additional information about the metric
      timestamp: time of the metric
      ```

  - `Traces`: 
    * allow you to follow operations as they traverse through the system, that way we can follow individual requests
    * each trace has a `trace-id` that can be used to identify a request
    * individual events that form a trace are called `spans` (e.g. gateway -> auth -> user -> db, 4 separate spans that form this trace)
    * each span tracks the `start time`, `duration`, and `parent-id`

- #### Prometheus
  
  * `Promethus` falls under the `metrics` pillar of observability
    - It is a monitoring solution for collecting and aggregating metrics

### SLI SLO SLA

* When designing a system its important to set specific measurable goals to help customers and end users quantify the level of reliability they should expect from that service
  - "Application should have 97% uptime in a rolling 30 day window"

- #### SLI
  * `SLI(Service Level Indicatior)`: metric that we can use to measure the quality of a service we provide
    1. `Request Latency`
    2. `Error Rate`
    3. `Saturation`
    4. `Throughput`
    5. `Availability`
    * You want to pick metrics that accurately meawsure a user's experience
      - Metrics like `high/cpu/high-mem` are poor `sli` indicators because a user might no have or see an impact on these events

- #### SLO
  * `SLO(Service Level Object)`: target values or range for an sli
    - (e.g. if we have an `sli` for latency then an `slo` would be `latency < 100ms`)
    * `SLOs` should be directly related to customer experience, should be able to quantify product reliability to end user

- #### SLA
  * `SLA(Service Level Agreement)`: contract between a vendor and a user that guarantees a certain `slo`
    - consequences of failure to meet an `slo` are usually financial in nature
