<h1>Cert Manager Issuers</h1>
* After `Cert-Manager` and its dependencies have been installed as discussed [here](https://eoyebami.github.io/k8s/cert-manager/2024-05-01-intro-to-cert-manager.html) we will need to configure what are known as `Issuers`

<h2>Issuers</h2>
* `Issuers` are Kubernetes resources that represent CAs that will sign csrs generated by `cert-manager`
* All certifcates generated by `cert-manager` require an issuer to validate the csr
  - There are a variety of `Issuers` that can be defined, from self-signed to a valid CA
    * All of which can be found [here](https://cert-manager.io/docs/configuration/issuers/)
* There are 2 types of `Issuers` that can be configured in your cluster
  - `ClusterIssuer`: non-namespaced scoped object, similar to a `clusterrole`
  - `Issuer`: namespaced scoped object, similar to a `role`

<h4>CA Issuer</h4>
* `CA Issuers` represents a CA whose certificate and private key are stored inside the clusters a `Secret` objects
  - Certificates issued by this `Issuer` will not be publicly trusted, so used this for internal use only
 
  ```yaml
  # create secret object with tls.crt and tls.key
  apiVersion: v1
  kind: Secret
  metadata:
    name: ca-key-pair
    namespace: istio-system
  data:
    tls.crt: xxxx | base64 # generate crt using openssl
    tls.key: xxxx | base64 # generate key using openssl
  ---
  apiVersion: cert-manager.io/v1
  kind: ClusterIssuer
  metadata:
    name: ca-issuer
  spec:
    ca:
      secretName: ca-key-pair # uses the selfsigned CA cert as its ca key for signing new request
  ```

<h4>SelfSigned Issuer</h4>
* `SeflSigned Issuers` don't represent a CA but rather asserts that certificates will sign themselves using a given private key
  - As the name suggests, the certificates will sign themselves
  
  ```yml
  # configure ClusterIssuer
  apiVersion: cert-manager.io/v1
  kind: ClusterIssuer
  metadata:
    name: selfsigned-cluster-issuer
  spec:
    selfSigned: {}
  ---
  # create a CA certificate 
  apiVersion: cert-manger.io/v1
  kind: Certificate
  metadata:
    name: selfsigned-cert
    name: istio-system
  spec:
    # this will either be the secret where the CA cert is generated or where cert-manager should retrieve it, if already created manually
    secretName: self-signed-ca-key-pair # using key generated from CA issuer
    isCa: true # specifies this cert as a CA cert
    issuerRef: # define ClusterIssuer that will use the cert to sign other certs
      name: ClusterIssuer
      kind: selfsigned-cluster-issuer
    commonName: "example.com" # primary FQDN
    dnsNames: # list of alternative DNS Names
    - "example.com"
    - "example01.com"
    # creates the privateKey and selfSigned Issuer will sign the key
  ---
  # bootstrap CA Issuer 
  apiVersion: cert-manager.io/v1
  kind: ClusterIssuer
  metadata:
    name: ca-issuer
  spec:
    ca:
      secretName: self-signed-ca-key-pair # uses the selfsigned CA cert as its ca key for signing new request
  ```

<h4>ACME Issuer</h4>
* `ACME Issuer` represents a single account registered with the `Automated Certificate Management Environment (ACME)` CA server
  - Certificates issued by the public `ACME` servers are typically widely trusted 
  - `Let-Encrypt` is the CA that facilitates all of this
* `ACME Issuers` also require a solving challenges to verify that the client owns the domains
* `Cert-Manager` offers two challenge validations
  - `HTTP01`: challenge that uses a computed key presented at a HTTP URL endpoint using the domain name requested
  - `DNS01`: challenge that uses a computed key presented within a DNS TXT record given by cert-manager. It supports multiple providers
    * ACMEDNS
    * Akamai
    * AzureDNS
    * CloudFlare
    * Google CloudDNS
    * Route53
    * DigitalOcean
    * RFC2136

<h5>ACME Issuer: Route53</h5>
* Using Route53 as the DNS provider
* First configure an IAM Role or User with the necessary secrets
  ```json
  {
  "Version": "2012-10-17",
  "Statement": [
      {
        "Effect": "Allow",
        "Action": "route53:GetChange",
        "Resource": "arn:aws:route53:::change/*"
      },
      {
        "Effect": "Allow",
        "Action": [
          "route53:ChangeResourceRecordSets",
          "route53:ListResourceRecordSets"
        ],
        "Resource": "arn:aws:route53:::hostedzone/*"
      },
      {
        "Effect": "Allow",
        "Action": "route53:ListHostedZonesByName",
        "Resource": "*"
      }
    ]
  }
  ```

* For Users, you can generate the accesskey and secretKey and store the secretKey in the Cluster 

  ```yml
  apiVersion: cert-manager.io/v1
  kind: ClusterIssuer
  metadata: 
    name: letsencrypt-prod
  spec:
    acme:
      email: user@example.com # add email that will be contacted when certs are about to expire or any other issues occur
      server: https://acme-v02.api.letsencrypt.org/directory # prod server
      # staging server is https://acme-staging-v02.api.letsencrypt.org/directory
      privateKeySecretRef:
        name: letencrypt-prod # cert-manager will create this for you
      solvers: # configure a challenge
      - dns01:
          route53:
            region: us-east-2 # region where your hosted zone is
            hostedZoneID: xxxx # hosted zone ID
            accessKeyID: xxxxx # accessKey for user, not recommended
            # accessKeyIDSecretRef: # if you want to reference a secret that has your accessKey
              # name: xxxx # name of secret
              # key: xxx # key of accessKey
            secretAccessKeySecretRef:
              name: xxxx # name of secret
              key: xxxx # key of secretKey
            # role: arn:aws:iam:<account-number>:role/cert-manager # if your user is meant to assume this role to access perms
  ```

* NOTE: if this is running in an EKS cluster, you can just map the role directly into the cluster as a service account and attach it to the `cert-manager` deployment 
* More info [here](https://cert-manager.io/docs/configuration/acme/dns01/route53/)

<h5>ACME Issuer: CloudDNS</h5>
* Using CloudDNS as the DNS Provider
* First configure a serviceaccount in gcloud with the necessary permissions

  ```bash
  gcloud iam service-accounts create dns01-solver --display-name "dns01-solver" --project-id ${PROJECT_ID}
  # add the following permissions to the service account
  dns.resourceRecordSets.*
  dns.changes.*
  dns.managedZones.list
  ```

* Create a key for that serviceaccount and create a secret from the corresponding json key file
  - `kubectl create secret generic dns01-solver-svc-acct --from-file=<json key file`

  ```yml
  apiVersion: cert-manager.io/v1
  kind: ClusterIssuer
  metadata:
    name: letsencrypt-prod
  spec:
    acme:
      email: user@example.com
      server: https://acme-v02.api.letsencrypt.org/directory
      privateKeySecretRef:
        name: letencrypt-prod
      solvers:
      - dns01:
          cloudDNS:
            project: xxxx # projectID
            serviceAccountSecretRef:
              name: xxxx # name of secret with sa key json
              key: xxxx # key of sa jey json
  ```

* More info [here](https://cert-manager.io/docs/configuration/acme/dns01/google/)
* NOTE: There are many more types off DNS Providers that can be configured, all of which can be found [here](https://cert-manager.io/docs/configuration/acme/dns01/)
